---
title: 模板类型推导
date: 2025-06-14 08:46:53
tags: [Modern C++,类型推导]
categories: c++基础
---

# 前言
类型推导使得程序员从冗杂的类型名拼写上解放出来，本篇文章将详细介绍模型类型推导的规则。

# 模板类型推导的规则
考虑如下函数模版：
```c++
template<typename T>
void f(ParamType param);
f(expr);
```
在编译期间，编译器使用`expr`进行两个类型的推导：`T`和`ParamType`。其中，`ParamType`通常包含一些修饰，从而通常与`T`是不同的类型。`T`的类型推导不仅取决于`expr`的类型，也被`ParamType`决定，可以将其分为三种情况：
* `ParamType`是一个指针或引用，但不是通用引用
* `ParamType`是一个通用引用
* `ParamType`既不是指针也不是引用
下面分别介绍三种情况下的类型推导规则

## 情况一：`ParamType`是一个指针或引用，但不是通用引用
在该情况下，类型推导按照如下规则进行：
* 如果`expr`的类型是一个引用，忽略引用部分
* `expr`的类型与`ParamType`进行模式匹配决定`T`
对于如下模板示例：
```c++
template <typename T>
void f(T& param)
```
则类型推导结果如下：
```c++
int x = 27;          // x是int
const int cx = x;    // cx是const int
const int& rx = x;   // rx是指向const int变量x的引用

f(x);  // T是int，param类型是int&
f(cx); // T是const int，param是const int&
f(rx); // T是const int，param是const int&
```
从上述结果中可以看出，**`const`对象作为实参传递给`T&`形参时，`const`会被保留为`T`的一部分**。

如果`param`是一个指针，对应的情况与引用基本一致：
```c++
template <typename T>
void f(T* param)

int x = 27;          // x是int类型
const int *px = &x;  // px是指向const int变量的指针

f(&x); // T是int，param是int*
f(px); // T是const int，param是const int*
```

## 情况二：`ParamType`是一个通用引用
该情况的形式如下：
```c++
template <typename T>
void f(T&& param)
```
对应的类型推导规则有以下几点：
* 如果`expr`是左值，`T`和`ParamType`都会被推导为左值引用。
* 如果`expr`是右值，使用情况一的推导规则（`T`保留`const`属性和基本类型，`param`是右值引用）
下面给出对应的示例：
```c++
template <typename T>
void f(T&& param)

int x = 27;
const int cx = x;
const int& rx = cx;

f(x);  // x是左值，T是int&，param也是int&
f(cx); // cx是左值，所以T是const int&，param也是const int&
f(rx); // rx是左值，所以T是const int&，param也是const int&
f(27); // 27是右值，所以T是int，param类型是int&&
```

## 情况三：`ParamType`既不是指针也不是引用
该情况下通过传值的方式处理：
```c++
template <typename T>
void f(T param)
```
对应如下规则：
* 如果`expr`的类型是一个引用，忽略这个引用部分
* 如果忽略`expr`的引用性之后，`expr`是一个`const`，那么再忽略`const`。如果是`volatile`，也忽略`volatile`。
下面给出对应的示例：
```c++
int x = 27;
const int cx = x;
const int& rx = cx;

f(x);  // T和param的类型都是int
f(cx); // T和param的类型都是int
f(rx); // T和param的类型都是int
```
该情况下，`param`是传入对象的拷贝，不影响传入对象。

一个例外情况是传入的是指向常量的常量指针，此时指针指向数据的常量性会被保留，而指针本身的常量性会被忽略：
```c++
template <typename T>
void f(T param)

const char* const ptr = "Fun with pointers"; // ptr是指向常量的常量指针
f(ptr); // param是const char*
```

# 数组实参
我们知道数组在某些上下文中会退化为指向它的第一个元素的指针，给出如下示例：
```c++
const char name[] = "J. P. Briggs";
const char * ptrToName = name;
```
在该示例中，`name`的类型为`const char[13]`，而`ptrToName`的类型为`const char*`，但编译器允许数组退化为指针。

将数组作为实参传递给模版：
```c++
template<typename T>
void f(T param);                        //传值形参的模板

f(name); // T被推导为const char*                             
```
有没有办法让`T`推导为数组，而不是指针呢？答案是使用传引用模板：
```c++
template <typename T>
void f(T& param);

f(name);
```
此时T会被推导为真正的数组`const char[13]`，形参类型为`const char (&)char[13]`。

我们可以根据这一性质创建一个模板函数推导数组的大小：
```c++
template <typename T, std::size_t N>
constexpr std::size_t arraySize(T (&)[N]) noexcept {
    return N;
}

int keyVals[] = {1, 3, 7, 9, 11, 22, 35};

int mappedVals[arraySize(keyVals)]; // 使用一个数组的大小声明另一个数组
```

# 函数实参
函数类型也会退化为函数指针，对于数组类型的推导可以应用到函数类型退化到函数指针上来：
```c++
void someFunc(int, double);         //someFunc是一个函数，
                                    //类型是void(int, double)

template<typename T>
void f1(T param);                   //传值给f1

template<typename T>
void f2(T & param);                 //传引用给f2

f1(someFunc);                       //param被推导为指向函数的指针，
                                    //类型是void(*)(int, double)
f2(someFunc);                       //param被推导为指向函数的引用，
                                    //类型是void(&)(int, double)
```

# 参考
[类型推导](https://cntransgroup.github.io/EffectiveModernCppChinese/1.DeducingTypes/item1.html)
